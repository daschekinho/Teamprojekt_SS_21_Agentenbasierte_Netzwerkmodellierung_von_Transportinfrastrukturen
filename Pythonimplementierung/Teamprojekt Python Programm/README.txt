Diese README-Datei soll einen kurzen Einblick in unseren Code liefern. Für eine detaillierte Beschreibung wird auf den im Rahmen des Teamprojekts enstandenen Bericht verwiesen.

AUTOREN: 
Sven Daschek, Jakob Freytag und Linus Schulze

GENERAL: 
Das von uns entwickelte Programm, wurde vor dem Hintergrund der Frage, wie sich sinkende Verfügbarkeiten und eine Verschlechterung des Infrastrukturzustandes eines multimodalen Transportnetzwerkes auswirken, erarbeitet. Dazu wurden insgesamt 4 Modules in Python implementiert: MultiLayerGraph.py, agent.py, layer.py und main.py. Das Netzwerk lässt sich anhand verschiedener Flags
und Eigenschaften der Layer individuell gestalten, auf die im Folgenden kurz näher eingegangen wird.

FLAGS/VARIABLEN:
Die Bedeutung der einstellbaren Flags, sollten durch die Kommentare im Code hinreichend geklärt sein. Die Flags können entweder im Code in main.py angepasst werden, oder falls default_network='nein' durch die Konsolenabfragen händisch eingegeben werden (zeitaufwendiger). Es sollte in beiden Fällen auf eine Eingabe ohne Fehler geachtet werden. Bei der Variante über die Konsoleneingabe wird man bei offensichtlichen Eingabefehlern aufmerksam gemacht.

NETZWERKAUFBAU:
Das zugrundeliegende Netzwerk, auf dem die Agenten sich fortbewegen, basiert auf der Netzwerkstruktur der einzelnen Layer.
Diese wird besonders durch die Methode gnp_random_connected_graph(n, p) in layer.py bestimmt. Der Algorithmus erzeugt dabei einen Graphen,
der ähnlich zum Erdos-Renyi-Graph ist, jedoch ohne isolierte Knoten. Übergabeparameter sind dabei die Anzahl an Knoten n und die Probability p, mit der Kanten verbunden werden. Es empfiehlt sich für p Werte zwischen 0.01 und 0.1 zu wählen. Ansonsten werden die Netzwerke zu dicht. Die Knotengrade vor und nach dem Verbinden der Layer können oben in der Konsolenausgabe überprüft werden. Die einzeln aufgebauten Netzwerke, werden anschließend mit hilfe von set_inter_layer_edges(), die die Hubs bestimmt, miteinander verbunden. Die Hubs werden dabei nach dem höchsten Knotengrad ausgewählt. Die Anzahl an Hubs pro Layer, wie zahlreiche andere Eigschaften der Layer können im Layer-Konstruktor angepasst werden.

AGENTENVERHALTEN:
Es ist zwischen zwei verschiedenen Typen von Agenten zu unterscheiden: der 'normale' Agent verfolgt, seine nach der Erzeugung direkt berechnete Route, über alle Perioden. Die Routenberechnung findet dabei nach dem Dijkstra-Algorithmus statt. Die Kanten haben dabei eine edge_time, die im Layer-Konstruktor eingestellt werden kann. Die default edge_time von Interlayeredges beträgt 5, kann jedoch angepasst werden. Zum anderen gibt es den perfekten Agenten, der jedesmal wenn er sich an einem Knoten befindet eine neue günstigste Route berechnet, die er ab dann verfolgt. Um das zu bewerkstelligen müssen die Kantenkosten in jeder Periode aktualisiert werden. Dazu mehr im Abschnitt update_edges. Perfekte Agenten meiden durch dieses Verhalten disruptete Knoten und redzuieren dadurch ihre tatsächlichen Routenkosten und sollten in der Theorie seltener failen. Allerdings wurde festgelegt, dass wenn diese Agenten ihre Route öfter als 3 mal wechseln, sie failen. Dieser Wert kann mit Rücksicht auf die Routenlängen angepasst werden.

UPDATE_EDGES/KOSTENVERHALTEN:
update_edges() wird insgesamt drei mal im Code aufgerufen. Und das jedesmal nachdem neue Agenten im Netzwerk generiert wurden, oder es eine Umstrukturierung der Agenten vor einer erneuten Routenberechnung gegeben hat. Dies hat den Grund, dass die Methode sich jeden Knoten im Netzwerk anschaut und guckt wie voll der Buffer ist bzw. wie viele Agenten an diesem Knoten warten und so anteilig die Kosten für Kanten, die zu diesem Knoten führen, erhöht. So werden die Kosten solange anteilig erhöht bis der Buffer vom Load her voll ist. Sollten danach noch Agenten an diesem Knoten warten wollen, failen sie aus dem Grund 'QUEUE'. Es werden außerdem weitere Unterscheidungen gemacht, auf die hier nicht weiter eingegangen wird. Insgesamt ist aber zu bemerken, dass die berechneten Kosten anhand der Knoten berechnet werden, aber an die Kanten weitertransferiert werden, weil diese zur Routenberechnung genutzt werden.

DISRUPTIONS:
Disruptions werden allgemein durch disrupt_network() in den definierten Intervallen disruptet und durch restore_network(), falls die Dauer der Disruption abgelaufen ist, aufgelöst. Bei den Disruptions ist auch zwischen zwei Typen zu unterscheiden. Der Totalausfall sorgt dafür, dass der betrachtete Knoten das Flag node_disrupted[]=True erhält und somit für Agenten, falls sie sich an diesem Knoten befinden der Grund ist warum sie failen. Zum anderen kann mit dem Flag dc_verändern eingestellt werden, dass zum einen trotzdem der Knoten als disruptet gilt, allerdings failen die Agenten nicht sofort, weil nun kein Totalausfall vorliegt sondern nur die Bufferkapazität und die Servicerate eingeschränkt werden. Diese Einschränkung kann entweder nach Ablauf der Dauer der Disruption komplett aufgehoben werden oder schrittweise, falls dc_aufhebung=True.

FAIL: 
Die einzelnen Fail-Gründe werden werden genauer im Bericht erklärt. Es sollte erwähnt werden, dass nicht mit jeder Konfiguration alle Fail Reasons auftauchen können. So gibt es bspw. Fail Reasons die abhängig vom perfekten Agenten sind. Eine gute Übersicht über die Fails liefert der Stackplot. Es kann teilweise zu überraschenden Ergebnissen kommen, die im Bericht versucht werden, erklärt zu werden.

PLOTS:
Insgesamt werden 7 Plots (bei 3 Layern) nach der Durchführung des Codes automatisch erzeugt. Es werden die Graphen der einzelnen Layer und des gesamten Netzwerks gezeichnet. (Hinweis: durch das Auskommentieren von nx.draw_networkx(self, ...) in main.py wird der Gesamtgraph nicht erstellt und so wird deutlich an Rechenzeit gespart. Ansonsten gibt es 2 Plots über die Verteilung des Agentenzustände, die einen ähnlichen Informationsgehalt haben, jedoch durch unterschiedliche Diagramme einen zusätzlichen Blickwinkel erlauben. Es gibt außerdem ein Kuchendiagramm mit einer Übersicht der gefailten Agenten und aus welchem Layer sie ursprünglich gestartet sind. Zuletzt gibt es noch eine Übersicht über die Top 5 Knoten mit dem höchsten Verkehraufkommen, d.h. der Anzahl an Agenten, die diesen Knoten benutzt haben. Ursprünglich war noch ein Plot über die Routenkosten der Agenten geplant. Es wurde entschlossen, diesen jedoch auszukommentieren, da nicht immer konsistente Ergebnisse geliefert wurden.